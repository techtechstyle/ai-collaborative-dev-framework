# フェーズ1.5 & フェーズ2 タスク分割

> **目的**: フェーズ1成果物の品質修正（1.5）と、XStateによる実行可能ステートチャート化（2）のタスク分割
> **作成日**: 2026-02-10
> **前提条件**: フェーズ1（T1〜T7）完了済み。全7成果物が存在。
> **方針**:
> - 「1文1検証」原則に従い、各タスクは1文で説明・検証1回で完了確認できる粒度
> - フェーズ2はTypeScript学習を兼ねて丁寧に進める
> - フェーズ2のゴールは「形式仕様文書 ＋ 動作するXStateプロトタイプ」の両方

---

## 全体構成

```
フェーズ1.5: T4/T6記法統一（4タスク）
  ↓
フェーズ2: XStateステートチャート化（16タスク）
  ├── Step A: 環境構築＋学習（T1〜T4）
  ├── Step B: 仕様定義（T5〜T8）
  ├── Step C: XState実装（T9〜T13）
  └── Step D: 統合＋検証（T14〜T16）
```

**総タスク数**: 20タスク（フェーズ1.5: 4 + フェーズ2: 16）

---

# フェーズ1.5: T4/T6記法統一

> **ゴール**: T4とT6のMermaid記法を統一し、フェーズ2の入力として一貫した成果物を確保する
> **想定期間**: 1〜2セッション
> **入力**: `phase1-t4-mermaid-flowcharts.md`, `phase1-t6-losscut-recovery-mermaid.md`

---

### T1: 記法差異の洗い出しと統一ルールの策定

**1文説明**: T4とT6のMermaid記法の差異をすべて列挙し、どちらの記法に統一するかのルールを定める。

**入力**: T4（424行）、T6（458行）の全Mermaid記法

**作業内容**:
- 開始/終了イベント記法の差異を確認
- ID命名規則の差異を確認
- style指定の有無の差異を確認
- データオブジェクト記法の差異を確認
- 上記を統一ルール表としてまとめる

**既知の差異（セッション引き継ぎ §4より）**:

| 要素 | T4の記法 | T6の記法 | 統一方針（この場で決定） |
|------|---------|---------|----------------------|
| 開始イベント | `(["テキスト"])` | `(("テキスト"))` | 要決定 |
| 終了イベント | `(("テキスト"))` | `((("テキスト")))` | 要決定 |
| style指定 | なし | あり（配色ルール適用） | 要決定 |
| ID命名 | `SE_1` | `LC_SE` | 要決定 |
| データオブジェクト | 図外で参照表 | `[("名称")]` で図内に配置 | 要決定 |
| 中間イベント | `{{テキスト}}` | `[/"テキスト"/]` | 要決定 |

**成果物**: `phase1.5-mermaid-style-guide.md`（統一ルール表）

**検証方法**: 統一ルール表にT4/T6間の全差異項目が網羅されており、各項目に統一方針が記載されていること

**自信度**: 確実（差異は構造的に抽出可能）

**Type**: 2（T4/T6の既存記法を参照して統一ルールを策定）

---

### T2: T4（メインフロー）への統一ルール適用

**1文説明**: T1で策定した統一ルールをT4の全6図に適用する。

**入力**: `phase1-t4-mermaid-flowcharts.md`, `phase1.5-mermaid-style-guide.md`

**作業内容**:
- T4の6つのMermaid図（§1〜§6）に統一ルールを適用
- ID命名、開始/終了イベント記法、style指定を修正

**対象図**: メインフロー、SP-1（L0-L3チェック）、SP-2（AIファーストチェック）、SP-3（検証ループ）、復帰フロー概要、TD（タスク分解）

**成果物**: `phase1-t4-mermaid-flowcharts.md`（更新版）

**検証方法**: T1の統一ルール表をチェックリストとして使用し、全6図が統一ルールに準拠していること

**自信度**: 確実（機械的な置換作業）

**Type**: 2（統一ルール表を参照して適用）

---

### T3: T6（損切り/復帰フロー）への統一ルール適用

**1文説明**: T1で策定した統一ルールをT6の全4図に適用する。

**入力**: `phase1-t6-losscut-recovery-mermaid.md`, `phase1.5-mermaid-style-guide.md`

**作業内容**:
- T6の4つのMermaid図（§1〜§4）に統一ルールを適用
- 必要に応じて記法を変更

**対象図**: 損切り判断（LC）、復帰フロー（RF）、エスカレーション判断（ES）、復帰全体俯瞰

**成果物**: `phase1-t6-losscut-recovery-mermaid.md`（更新版）

**検証方法**: T1の統一ルール表をチェックリストとして使用し、全4図が統一ルールに準拠していること

**自信度**: 確実（機械的な置換作業）

**Type**: 2（統一ルール表を参照して適用）

---

### T4: 全10図のレンダリング検証

**1文説明**: 修正後のT4（6図）とT6（4図）の全10図がMermaidプレビューで正しく描画されることを確認する。

**入力**: 更新後のT4、T6

**作業内容**:
- 各図をMermaidプレビュー（VSCode拡張/Mermaid Live Editor等）で表示確認
- 描画崩れ、矢印の欠落、ラベルの切れ等がないか確認
- 問題があれば修正

**成果物**: レンダリング検証結果の記録（OK/NG + 修正内容）

**検証方法**: 全10図がエラーなく描画され、フロー構造がT3/T5のBPMN定義と一致していること

**自信度**: おそらく（描画ツールの挙動に依存する部分あり）

**Type**: 1（ツールで確認するだけ、既存コード参照不要）

---

### フェーズ1.5 依存関係

```
T1（統一ルール策定）
├── T2（T4に適用）──┐
└── T3（T6に適用）──┴── T4（レンダリング検証）
```

- T2とT3は並行実施可能
- T4はT2/T3の両方が完了してから実施

---

# フェーズ2: XStateステートチャート化

> **ゴール**: フレームワークの判断フローをHarelステートチャートとして形式定義し、XState（TypeScript）で動作するプロトタイプを構築する
> **想定期間**: 5〜10セッション（TypeScript学習を含む）
> **入力**: フェーズ1全成果物（T1〜T7）＋リサーチレポート
> **ゴール成果物**:
> 1. ステートチャート形式仕様書（各フローのステートチャート設計をMarkdownで記述）
> 2. XState実装（TypeScriptコード。`npm test`で検証可能）

---

## Step A: 環境構築＋学習（T1〜T4）

> TypeScript/XStateの基礎を学び、開発環境を整える。

---

### T1: Node.js + TypeScript + XState 開発環境の構築

**1文説明**: XState v5のTypeScriptプロジェクトを作成し、`npm run typecheck`が通る状態にする。

**作業内容**:
- Node.js + npm の確認
- TypeScript プロジェクト初期化（`tsconfig.json`）
- XState v5 インストール（`npm install xstate`）
- Vitest インストール（テスト用）
- 最小限の「Hello World」ステートマシンを作成してtypecheckを通す

**成果物**: プロジェクトディレクトリ（`package.json`, `tsconfig.json`, `src/hello.ts`）

**検証方法**: `npm run typecheck` がエラー0で通過すること

**自信度**: 確実（定型的な環境構築）

**Type**: 1

---

### T2: XStateの基本概念を理解する（ティーチングモード）

**1文説明**: XState v5の7つの基本概念（状態、遷移、イベント、アクション、ガード、ネスト状態、並行状態）を、フレームワークの具体例に対応づけて理解する。

**作業内容**:
- 各概念の説明をフレームワーク用語に対応させて学ぶ
  - 状態（state）→ L0チェック中、L1チェック中、等
  - 遷移（transition）→ L0通過 → L1チェックへ
  - イベント（event）→ CHECK_PASS、CHECK_FAIL、TIMEOUT
  - アクション（action）→ エラー状態記録、CLAUDE.md更新
  - ガード（guard）→ isLevel0Pass、isWithin30Min
  - ネスト状態 → L0-L4階層
  - 並行状態 → 検証ループ＋協働原則監視

**成果物**: `docs/xstate-concepts-mapping.md`（XState概念 ↔ フレームワーク要素の対応表）

**検証方法**: 7つの概念すべてにフレームワーク内の具体的な対応要素が記載されていること

**自信度**: 確実（概念レベルの対応づけ）

**Type**: 1

---

### T3: XStateの履歴状態と遅延遷移を理解する（ティーチングモード）

**1文説明**: XState v5の履歴状態（history state）と遅延遷移（delayed transition）を、復帰フローと損切り30分ルールに対応づけて理解する。

**作業内容**:
- 履歴状態の動作を理解（shallow / deep history）
  - 対応: RF（復帰フロー）から損切り前の文脈に復帰する仕組み
- 遅延遷移（`after`）の動作を理解
  - 対応: INV-LC2の30分ルール（`after(30min) → lossCut`）
- それぞれの最小サンプルコードを実装して動作確認

**成果物**: `src/learning/history-example.ts`, `src/learning/delay-example.ts`

**検証方法**: 各サンプルが `npm test` で期待どおりに動作すること（履歴状態は復帰先が正しいこと、遅延遷移はタイムアウトで遷移すること）

**自信度**: おそらく（XState v5の挙動を実際に確認する必要がある）

**Type**: 1

---

### T4: ステートチャートとBPMN/Mermaidフローの構造的対応を整理する

**1文説明**: フェーズ1のBPMN要素68個を、ステートチャートの構成要素（状態、遷移、アクション、ガード）へのマッピングルールとして整理する。

**作業内容**:
- BPMN要素 → ステートチャート要素のマッピングルールを定義

| BPMN要素 | ステートチャート要素 | 例 |
|----------|-------------------|-----|
| 開始イベント | 初期状態 | SE-1 → `initial: 'brightLinesCheck'` |
| タスク | 状態 + entry アクション | T-1 → `brightLinesFix` state |
| サブプロセス | ネスト状態（compound state） | SP-1 → `l0l3Check` compound state |
| 排他ゲートウェイ | ガード付き遷移 | GW-1 → `guard: 'hasBrightLineViolation'` |
| 終了イベント | 最終状態 | EE-1 → `type: 'final'` |
| 中間イベント（タイマー） | 遅延遷移 | SP3-IE1 → `after: { 1800000: 'lossCut' }` |
| データオブジェクト | コンテキスト | D-1 → `context.claudeMd` |

**成果物**: `docs/bpmn-to-statechart-mapping.md`

**検証方法**: T3の68個のBPMN要素のうち、データオブジェクト（D-1〜D-8の8個）を除く60要素すべてにマッピングルールが定義されていること

**自信度**: おそらく（一部のBPMN要素は1対1でマッピングできない可能性あり）

**Type**: 2（T3のBPMN要素リストを参照）

---

## Step B: 仕様定義（T5〜T8）

> 各フローのステートチャート形式仕様をMarkdownで定義する。
> XState実装の前に「何を作るか」を明確にする段階。

---

### T5: L0-L4階層のステートチャート仕様を定義する

**1文説明**: L0→L1→L2→L3→L4の5層意思決定階層を、Harelステートチャートのネスト構造として形式的に定義する。

**入力**: T1（決定条件）、T2（DT-1〜DT-5）、T7（INV-H1〜H5, INV-SP1-1〜SP1-5）

**作業内容**:
- L0を最外殻のスーパーステートとして定義
- L0内にL1、L1内にL2…とネストさせる
- 各レベルの通過/不通過をガード条件として定義
- DT-1のヒットポリシーF（最初一致）を遷移ロジックに反映
- INV-H1（評価順序不逆転）、INV-H2（上位No→下位未評価）を設計制約として組み込む

**成果物**: `docs/spec-l0l4-hierarchy.md`（状態図の定義、ガード条件一覧、遷移表、対応する不変条件の検証ポイント）

**検証方法**: INV-H1〜H5、INV-SP1-1〜SP1-5の10個の不変条件が設計上すべて保証されていること（各不変条件に対して「設計のどの部分で保証されるか」が記載されていること）

**自信度**: おそらく（ネスト設計の最適な深さは実装時に調整の可能性あり）

**Type**: 2（T1, T2, T7を参照）

---

### T6: メインフロー＋SP-2のステートチャート仕様を定義する

**1文説明**: メインフロー（Bright Lines → L0-L3チェック → AIファースト判断 → 実行 → 検証）とSP-2（AIファーストチェック＋分業判断）のステートチャートを定義する。

**入力**: T3（BPMN要素）、T4（Mermaid図 §1, §3）、T7（INV-MF1〜MF6, INV-SP2-1〜SP2-4）

**作業内容**:
- メインフローを最上位ステートマシンとして定義
- SP-1（T5で定義済み）、SP-2をネスト状態として組み込む
- GW-1〜GW-4のゲートウェイをガード付き遷移に変換
- DT-0（Bright Lines）、DT-6（分業判断）をガード条件に反映
- 人間主導パス（T-3）とAI主導パス（T-4→T-5）の排他分岐を定義

**成果物**: `docs/spec-main-flow.md`

**検証方法**: INV-MF1〜MF6、INV-SP2-1〜SP2-4の10個の不変条件が設計上すべて保証されていること

**自信度**: おそらく

**Type**: 2（T3, T4, T7を参照）

---

### T7: 検証ループ＋損切りのステートチャート仕様を定義する

**1文説明**: SP-3（typecheck→lint→test＋協働原則監視）と損切り判断（LC: 4条件OR評価＋短絡評価）のステートチャートを定義する。

**入力**: T3 §4（SP-3 BPMN）、T5 §1（LC BPMN）、T7（INV-SP3-1〜SP3-5, INV-LC1〜LC5）

**作業内容**:
- SP-3の逐次検証（typecheck→lint→test）を逐次状態遷移として定義
- 協働原則チェック（DT-8）とAI行動原則チェック（DT-9）を並行状態として定義
- 損切り4条件のOR判定＋短絡評価を遷移ロジックとして定義
- 30分タイマー（SP3-IE1）と3回カウンター（SP3-IE2）を遅延遷移/ガード条件に変換
- INV-LC5（中間イベントによる強制起動）の実現方法を設計

**成果物**: `docs/spec-verification-losscut.md`

**検証方法**: INV-SP3-1〜SP3-5、INV-LC1〜LC5の10個の不変条件が設計上すべて保証されていること

**自信度**: おそらく（並行状態と損切りの統合は設計上の判断が複数あり得る）

**Type**: 2（T3, T5, T7を参照）

---

### T8: 復帰フロー＋エスカレーションのステートチャート仕様を定義する

**1文説明**: RF（復帰フロー: 分析→アプローチ選択→CLAUDE.md記録→メインフロー復帰）とES（エスカレーション判断）のステートチャートを定義する。

**入力**: T5 §2,§3（RF/ES BPMN）、T6 §2,§3（Mermaid図）、T7（INV-RF1〜RF6, INV-ES1〜ES3）

**作業内容**:
- 復帰フローの3ステップ（分析→実行→記録）を逐次状態として定義
- 4アプローチ（A: 直接解決/B: 再分解/C: リセット/D: エスカレーション）の排他分岐を定義
- 履歴状態を活用した損切り前文脈の保持・復帰メカニズムを設計
- INV-RF2（CLAUDE.md記録の必須性）を全アプローチパスの合流点として設計
- エスカレーション判断の2段階ゲートウェイ（即座/30分以内）を定義
- RF-EE → メインフロー SE-1 への復帰遷移を定義

**成果物**: `docs/spec-recovery-escalation.md`

**検証方法**: INV-RF1〜RF6、INV-ES1〜ES3の9個の不変条件が設計上すべて保証されていること

**自信度**: おそらく（履歴状態の具体的な設計は実装段階で調整の可能性あり）

**Type**: 2（T5, T6, T7を参照）

---

## Step C: XState実装（T9〜T13）

> Step Bの仕様をTypeScript/XStateコードとして実装する。
> 各タスクに対応するテストも同時に作成する。

---

### T9: L0-L4階層をXStateで実装する

**1文説明**: T5の仕様に基づき、L0→L1→L2→L3→L4の5層ネスト状態マシンをXState v5で実装し、INV-H1〜H5が通るテストを書く。

**入力**: `docs/spec-l0l4-hierarchy.md`（T5成果物）

**作業内容**:
- `src/machines/l0l4-hierarchy.ts` を作成
- 5層のネスト状態をXStateのcreateActor/createMachineで定義
- 各レベルのガード条件を実装
- INV-H1〜H5に対応するテストケースを作成

**テストケース例**:
- L0=No → L1以降が評価されないこと（INV-H2）
- L0=Yes, L1=Yes, L2=Yes, L3=Yes → L4が評価されること（INV-H3）
- L4から始めることができないこと（INV-H1）

**成果物**: `src/machines/l0l4-hierarchy.ts`, `src/machines/__tests__/l0l4-hierarchy.test.ts`

**検証方法**: `npm test -- l0l4-hierarchy` が全件パスすること

**自信度**: おそらく（XState v5のネスト状態の実装詳細に依存）

**Type**: 2（T5仕様を参照して実装）

---

### T10: メインフロー＋SP-2をXStateで実装する

**1文説明**: T6の仕様に基づき、メインフロー（Bright Lines→L0-L3→AIファースト判断→実行→検証）とSP-2（分業判断）をXStateで実装し、INV-MF1〜MF6/INV-SP2-1〜SP2-4が通るテストを書く。

**入力**: `docs/spec-main-flow.md`（T6成果物）、T9の実装（L0-L4階層）

**作業内容**:
- `src/machines/main-flow.ts` を作成
- T9のL0-L4階層をサブステートとして組み込む
- Bright Linesチェック（DT-0）のガード条件を実装
- 人間主導/AI主導パスの排他分岐を実装
- INV-MF1〜MF6、INV-SP2-1〜SP2-4に対応するテストを作成

**成果物**: `src/machines/main-flow.ts`, `src/machines/__tests__/main-flow.test.ts`

**検証方法**: `npm test -- main-flow` が全件パスすること

**自信度**: おそらく

**Type**: 2（T6仕様 + T9実装を参照）

---

### T11: 検証ループをXStateで実装する

**1文説明**: T7の仕様に基づき、SP-3（typecheck→lint→test + 協働原則並行監視）をXStateで実装し、INV-SP3-1〜SP3-5が通るテストを書く。

**入力**: `docs/spec-verification-losscut.md`（T7成果物）

**作業内容**:
- `src/machines/verification-loop.ts` を作成
- typecheck→lint→testの逐次状態遷移を実装
- 協働原則チェック（DT-8）とAI行動原則チェック（DT-9）の並行状態を実装
- 各検証失敗時の損切り判断への遷移を実装
- INV-SP3-1〜SP3-5に対応するテストを作成

**テストケース例**:
- typecheck失敗 → lint/testが実行されないこと（INV-SP3-2）
- 全検証成功 → 正常終了すること（INV-SP3-5）
- 検証失敗 → 損切り判断が起動すること（INV-SP3-4）

**成果物**: `src/machines/verification-loop.ts`, `src/machines/__tests__/verification-loop.test.ts`

**検証方法**: `npm test -- verification-loop` が全件パスすること

**自信度**: おそらく

**Type**: 2（T7仕様を参照）

---

### T12: 損切り判断をXStateで実装する

**1文説明**: T7の仕様に基づき、損切り判断（4条件OR＋短絡評価＋30分タイマー）をXStateで実装し、INV-LC1〜LC5が通るテストを書く。

**入力**: `docs/spec-verification-losscut.md`（T7成果物）

**作業内容**:
- `src/machines/losscut-judgment.ts` を作成
- 4条件（3回/30分/複雑化/再発）の逐次判定を実装
- OR評価＋短絡評価をガード付き遷移として実装
- `after(1800000)` による30分タイマーを実装
- エラーカウンターによる3回ルールを `context` で管理
- INV-LC1〜LC5に対応するテストを作成

**テストケース例**:
- 3回目のエラー → 即座に損切り確定（INV-LC2, INV-LC4短絡評価）
- 30分経過 → 損切り確定（INV-LC2, INV-LC5）
- 4条件すべてNo → 修正継続（INV-LC3）

**成果物**: `src/machines/losscut-judgment.ts`, `src/machines/__tests__/losscut-judgment.test.ts`

**検証方法**: `npm test -- losscut-judgment` が全件パスすること

**自信度**: おそらく（タイマーのテスト方法はXStateのfake timer機能に依存）

**Type**: 2（T7仕様を参照）

---

### T13: 復帰フロー＋エスカレーションをXStateで実装する

**1文説明**: T8の仕様に基づき、復帰フロー（分析→アプローチ選択→CLAUDE.md記録→復帰）とエスカレーション判断をXStateで実装し、INV-RF1〜RF6/INV-ES1〜ES3が通るテストを書く。

**入力**: `docs/spec-recovery-escalation.md`（T8成果物）

**作業内容**:
- `src/machines/recovery-flow.ts` を作成
- 3ステップ（分析→実行→記録）の逐次状態を実装
- 4アプローチの排他分岐をガード付き遷移で実装
- CLAUDE.md記録（RF-T9）の全パス合流を設計
- 履歴状態によるメインフロー復帰を実装
- エスカレーション判断の2段階ゲートウェイを実装
- INV-RF1〜RF6、INV-ES1〜ES3に対応するテストを作成

**テストケース例**:
- アプローチA選択 → RF-T9（CLAUDE.md記録）が実行されること（INV-RF2）
- アプローチD選択 → エスカレーション判断が起動すること
- セキュリティ問題 → 即座にエスカレーション（INV-ES2）
- 復帰完了 → メインフローSE-1に戻ること（INV-RF4）

**成果物**: `src/machines/recovery-flow.ts`, `src/machines/__tests__/recovery-flow.test.ts`

**検証方法**: `npm test -- recovery-flow` が全件パスすること

**自信度**: おそらく

**Type**: 2（T8仕様を参照）

---

## Step D: 統合＋検証（T14〜T16）

> 個別のステートマシンを統合し、全体の整合性を検証する。

---

### T14: 全マシンの統合とフロー間接続の実装

**1文説明**: T9〜T13で実装した5つのステートマシンを統合し、フロー間の遷移（Main→SP-1→SP-2→SP-3→LC→RF→Main）が正しく動作するテストを書く。

**入力**: T9〜T13の全実装ファイル、T7（INV-CF1〜CF5）

**作業内容**:
- `src/machines/integrated-flow.ts` を作成
- 5つのマシンをXStateのinvoke/spawn/actorで接続
- フロー間遷移のテストを作成
- INV-CF1〜CF5に対応するテストを作成

**テストケース例**:
- Main→SP-1→SP-2→SP-3の順序が固定（INV-CF1）
- SP-3失敗→LCのみに遷移（INV-CF2）
- LC→RF→Main SE-1の一方向遷移（INV-CF3, INV-CF4）

**成果物**: `src/machines/integrated-flow.ts`, `src/machines/__tests__/integrated-flow.test.ts`

**検証方法**: `npm test -- integrated-flow` が全件パスすること

**自信度**: 不確実（マシン間の接続パターンは実装時に設計判断が必要）

**Type**: 2（T9〜T13の実装 + T7の不変条件を参照）

---

### T15: Bright Lines不変条件とデータオブジェクト不変条件の統合テスト

**1文説明**: Bright Lines（INV-BL1〜BL4）、データオブジェクト（INV-DO1〜DO6）、協働/AI行動原則（INV-CA1〜CA3）の不変条件が統合フローで保証されるテストを書く。

**入力**: T14の統合実装、T7（INV-BL, INV-DO, INV-CA）

**作業内容**:
- Bright Lines違反シナリオのテスト（BL1〜BL4各違反パターン）
- データオブジェクトの整合性テスト（CLAUDE.md更新タイミング、AI出力のレビュー必須性等）
- 協働原則/AI行動原則チェックのテスト

**成果物**: `src/machines/__tests__/invariants-integration.test.ts`

**検証方法**: `npm test -- invariants-integration` が全件パスすること

**自信度**: おそらく

**Type**: 2（T14実装 + T7不変条件を参照）

---

### T16: 不変条件カバレッジ表の作成と全体レビュー

**1文説明**: T7の全74個の不変条件に対して、XState実装のどのテストケースで検証されているかの対応表を作成し、カバレッジを確認する。

**入力**: T7（74不変条件）、T9〜T15の全テストファイル

**作業内容**:
- 74不変条件の各IDに対して、検証しているテストケースを紐づけ
- カバレッジ率を算出（目標: 主要不変条件の90%以上）
- 未カバーの不変条件があれば理由を記録（形式化困難/実装範囲外等）

**成果物**: `docs/invariant-coverage-report.md`

**検証方法**: 全74不変条件に対して「カバー済み/未カバー（理由付き）」の分類が完了していること

**自信度**: 確実（対応表の作成は機械的な作業）

**Type**: 2（T7 + 全テストファイルを参照）

---

## フェーズ2 依存関係の全体図

```
Step A: 環境構築＋学習
  T1（環境構築）
  T2（基本概念理解）
  T3（履歴状態＋遅延遷移理解）── T1に依存
  T4（BPMN→ステートチャートマッピング）
      │
Step B: 仕様定義
  T5（L0-L4仕様）──── T4に依存
  T6（メイン+SP-2仕様）── T4, T5に依存
  T7（検証+損切り仕様）── T4に依存
  T8（復帰+ES仕様）──── T4に依存
      │
Step C: XState実装
  T9（L0-L4実装）──── T1, T5に依存
  T10（メイン+SP-2）── T9, T6に依存
  T11（検証ループ）── T1, T7に依存
  T12（損切り判断）── T1, T3, T7に依存
  T13（復帰+ES）──── T1, T3, T8に依存
      │
Step D: 統合＋検証
  T14（統合）────── T9〜T13すべてに依存
  T15（統合テスト）── T14に依存
  T16（カバレッジ）── T15に依存
```

### 並行実施可能なタスク

| タイミング | 並行可能なタスク |
|-----------|----------------|
| Step A | T1 + T2 + T4 を並行。T3はT1の後 |
| Step B | T5, T7, T8 を並行（T6はT5の後） |
| Step C | T11, T12 を並行（T10はT9の後。T13はT3の後） |

---

## 成果物一覧

### フェーズ1.5

| # | 成果物 | 種別 |
|---|-------|------|
| 1 | `phase1.5-mermaid-style-guide.md` | ガイドライン |
| 2 | `phase1-t4-mermaid-flowcharts.md`（更新版） | 更新ドキュメント |
| 3 | `phase1-t6-losscut-recovery-mermaid.md`（更新版） | 更新ドキュメント |
| 4 | レンダリング検証結果 | チェック記録 |

### フェーズ2

| # | 成果物 | 種別 |
|---|-------|------|
| 1 | `docs/xstate-concepts-mapping.md` | 学習ドキュメント |
| 2 | `docs/bpmn-to-statechart-mapping.md` | 設計ドキュメント |
| 3 | `docs/spec-l0l4-hierarchy.md` | 形式仕様 |
| 4 | `docs/spec-main-flow.md` | 形式仕様 |
| 5 | `docs/spec-verification-losscut.md` | 形式仕様 |
| 6 | `docs/spec-recovery-escalation.md` | 形式仕様 |
| 7 | `src/machines/l0l4-hierarchy.ts` + テスト | XState実装 |
| 8 | `src/machines/main-flow.ts` + テスト | XState実装 |
| 9 | `src/machines/verification-loop.ts` + テスト | XState実装 |
| 10 | `src/machines/losscut-judgment.ts` + テスト | XState実装 |
| 11 | `src/machines/recovery-flow.ts` + テスト | XState実装 |
| 12 | `src/machines/integrated-flow.ts` + テスト | XState実装 |
| 13 | `docs/invariant-coverage-report.md` | 検証レポート |

---

## リスクと対策

| リスク | 影響度 | 対策 |
|--------|-------|------|
| XState v5のネスト状態の深さ制限 | 中 | Step Bの仕様定義段階で3〜4層程度に抑える設計を検討 |
| 並行状態（SP-3の検証＋原則監視）の実装複雑度 | 中 | T3の学習タスクで並行状態を先に体験してから仕様策定 |
| タイマーテストの困難さ | 小 | XStateのuseFakeTimers / clock APIを事前に確認（T3） |
| マシン間接続パターンの設計判断 | 大 | T14で複数案を比較検討し、最もシンプルな方法を選択 |
| TypeScript型の複雑度 | 中 | XState v5のtypegen機能を活用。難しい場合はany一時回避 |

---

## スコープ外（フェーズ3以降の候補）

以下はフェーズ2のスコープには含めず、提案として記録する。

1. **TLA+による不変条件の形式検証** — リサーチレポートのフェーズ3に相当。T16のカバレッジ結果を見て判断
2. **XState Visualizerによるインタラクティブ可視化** — フレームワーク公開時に有用
3. **Camunda/BPMN 2.0での実行可能ワークフロー化** — リサーチレポートのフェーズ4に相当
4. **決定表のランタイムチェック自動化** — CLAUDE.mdへの組み込み検討
5. **定量的メトリクス（複雑度閾値等）の導入** — 運用データ蓄積後
