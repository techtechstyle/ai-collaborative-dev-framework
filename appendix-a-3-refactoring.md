# 付録A-3: ウォークスルー例 - 既存コードのリファクタリング

> **📖 ドキュメント種類**: Tutorial（学習志向・行動）
>
> **この付録について**: 技術的負債を抱えた既存コードを段階的に改善する
> リファクタリングを題材に、損切り判断と段階的な改善の実践を学びます。
>
> **読むタイミング**: 
> - 付録A-1, A-2を完了した後の応用として
> - レガシーコードの改善に取り組む前の参考として
>
> **前提**: 
> - [付録A-1](./appendix-a-walkthrough.md), [付録A-2](./appendix-a-2-csv-pipeline.md) を完了していること
> - リファクタリングの基本概念を理解していること
>
> **所要時間**: 約60-90分
>
> **難易度**: ⭐⭐⭐ 上級（損切り判断、段階的改善、失敗からの学び）

### このチュートリアルで学べること

| # | 学習内容 | 関連する原則 |
|---|---------|-------------|
| 1 | 既存コードの分析と改善計画 | H3: 準備と振り返りに投資 |
| 2 | 損切り判断とリカバリー | P2: 損切りは判断 |
| 3 | 段階的な改善アプローチ | P3: 完璧より改善 |
| 4 | 失敗の記録と学び | P1: 責めない・記録する |

---

## シナリオ

あなたは既存の注文処理システムのリファクタリングを任されました。
このコードは数年前に書かれ、以下の問題を抱えています。

**現状の問題:**
- 1つの関数が500行を超えている
- any型が多用されている
- テストがない
- エラーハンドリングが不十分

**対象ファイル:**
```typescript
// src/services/OrderService.ts (問題のあるコード)
export class OrderService {
  async processOrder(data: any): Promise<any> {
    // 500行の巨大関数...
    // バリデーション、在庫確認、決済、通知がすべて混在
  }
}
```

**ゴール:**
- 関数を責務ごとに分割
- any型を具体的な型に置換
- 各責務にテストを追加

---

## Step 0 — リファクタリング前の準備

### 重要: まず「壊さない」ことを確認する

リファクタリングの前に、**現在の動作を保証する手段**を確保します。

```
┌─────────────────────────────────────────────────────────────────┐
│              リファクタリング前のチェックリスト                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  □ 現在の動作が確認できるか?                                   │
│    - 手動テスト手順がある、または                               │
│    - 統合テストがある、または                                   │
│    - 本番ログで動作確認できる                                   │
│                                                                 │
│  □ ロールバック手段があるか?                                   │
│    - Gitブランチを作成した                                      │
│    - 元のコードをバックアップした                               │
│                                                                 │
│  □ 影響範囲を把握しているか?                                   │
│    - このコードを呼び出している箇所を特定した                   │
│    - 依存しているモジュールを把握した                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Claudeへの指示（分析フェーズ）

```
「OrderService.ts のリファクタリングを計画しています。

まず、現状分析をしてください。

対象: src/services/OrderService.ts

分析してほしいこと:
1. processOrder関数の責務の洗い出し（何をやっているか）
2. 使用されている外部依存（他のサービス、リポジトリ）
3. 入力データの構造（data引数の実際の形）
4. 出力データの構造（戻り値の実際の形）
5. エラーが発生しうる箇所

分析結果を箇条書きで報告してください。
コードの変更はまだ行わないでください。」
```

**期待される出力:**

```
分析結果:

1. 責務の洗い出し:
   - 入力バリデーション（50-100行目）
   - 在庫確認（101-200行目）
   - 決済処理（201-350行目）
   - 通知送信（351-450行目）
   - ログ記録（各所に散在）

2. 外部依存:
   - InventoryRepository
   - PaymentGateway
   - NotificationService
   - Logger

3. 入力データ構造:
   { userId, items[], paymentMethod, shippingAddress }

4. 出力データ構造:
   { orderId, status, totalAmount, estimatedDelivery }

5. エラー発生箇所:
   - 在庫不足（201行目）
   - 決済失敗（280行目）
   - 通知失敗（400行目、握りつぶし）
```

---

## Step 1 — リファクタリング計画の作成

分析結果をもとに、**段階的な改善計画**を立てます。

### 重要な原則: 一度にすべてを変えない

```
┌─────────────────────────────────────────────────────────────────┐
│              リファクタリングの鉄則                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ❌ やってはいけないこと                                        │
│  ・一度にすべてを書き換える                                     │
│  ・テストなしで構造を変更する                                   │
│  ・「ついでに」機能追加する                                     │
│                                                                 │
│  ✅ やるべきこと                                                │
│  ・1つの責務を切り出す → テスト追加 → 次へ                    │
│  ・動作確認してからコミット                                     │
│  ・リファクタリングと機能追加を分ける                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 分解結果

```
大タスク: OrderService のリファクタリング

分解結果（優先度順）:
1. 入力バリデーションの切り出し + 型定義
   - 完了条件: typecheck通過、既存動作に影響なし
   - 所要時間目安: 20分
   - リスク: 低

2. 在庫確認ロジックの切り出し
   - 完了条件: typecheck + 単体テスト通過
   - 所要時間目安: 25分
   - リスク: 中（外部依存あり）

3. 決済処理の切り出し
   - 完了条件: typecheck + 単体テスト通過
   - 所要時間目安: 30分
   - リスク: 高（決済は失敗が許されない）

4. 通知処理の切り出し + エラーハンドリング改善
   - 完了条件: 全検証通過
   - 所要時間目安: 20分
   - リスク: 低

合計: 約95分（バッファ込み）
```

---

## Step 2 — 入力バリデーションの切り出し

最もリスクが低い部分から始めます。

### Claudeへの指示

```
「OrderServiceのリファクタリングを開始します。

まず、入力バリデーションを切り出してください。

作成するファイル:
- src/services/order/validators/OrderInputValidator.ts
- src/services/order/types/OrderInput.ts

要件:
- 現在のprocessOrder関数の50-100行目にあるバリデーションロジックを移動
- any型を具体的な型（OrderInput）に置換
- zodスキーマでバリデーション

制約:
- 元のprocessOrder関数は呼び出し元を変更する
- 動作は変わらないこと（入力→出力の関係を維持）

完了したら typecheck を実行して、既存のコードに影響がないことを確認してください。」
```

### 検証

```bash
npm run typecheck
```

**期待される出力:**
```
Found 0 errors.
```

### 動作確認

リファクタリング後、元の機能が動作することを確認します。

```bash
# 手動テストまたは既存の統合テスト
npm run test:integration -- OrderService
```

**この時点でコミット:**

```bash
git add .
git commit -m "refactor: OrderServiceから入力バリデーションを切り出し"
```

---

## Step 3 — 在庫確認ロジックの切り出し【損切りポイント】

このステップは外部依存（InventoryRepository）があるため、
**損切りラインを明確に設定**します。

### 損切り条件

```
┌─────────────────────────────────────────────────────────────────┐
│                    Step 3 の損切りライン                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ⚠️ 以下の場合は損切りを検討:                                   │
│                                                                 │
│  1. InventoryRepositoryのインターフェースが複雑すぎる           │
│     → 先にリポジトリの整理タスクを実行                          │
│                                                                 │
│  2. 30分以上経過してもtypecheckが通らない                       │
│     → いったんStep 2の状態でコミット、別タスクとして分離        │
│                                                                 │
│  3. テストの作成が困難（モックが複雑）                          │
│     → リポジトリのテスタビリティ改善を先に実行                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Claudeへの指示

```
「次に、在庫確認ロジックを切り出してください。

作成するファイル:
- src/services/order/InventoryChecker.ts
- src/services/order/InventoryChecker.test.ts

要件:
- processOrderの101-200行目にある在庫確認ロジックを移動
- InventoryRepositoryを依存性注入で受け取る
- Result型で成功/失敗を返す

テスト:
- 在庫あり → 成功
- 在庫不足 → エラー（どの商品が不足か明示）
- リポジトリエラー → エラー伝播

完了したら typecheck と test を実行してください。」
```

### 検証

```bash
npm run typecheck && npm run test -- InventoryChecker
```

<details>
<summary>🚨 損切りが必要になった場合の対処</summary>

**シナリオ: InventoryRepositoryのインターフェースが複雑すぎる**

```
「InventoryRepositoryのインターフェースが複雑で、
在庫確認の切り出しが困難です。

一旦、在庫確認の切り出しは保留します。
代わりに、以下のタスクを先に実行してください:

1. InventoryRepositoryのインターフェースを分析
2. checkStock()メソッドに必要な最小限のインターフェースを定義
3. 現在の実装がそのインターフェースを満たすかを確認

分析結果を報告してください。」
```

**シナリオ: テストのモックが複雑すぎる**

```
「テストの作成が困難です。

まず、InventoryRepositoryをモックしやすい形に
リファクタリングするタスクを先に実行してください。

要件:
- インターフェース（IInventoryRepository）を定義
- 現在の実装をそのインターフェースに適合させる

これが完了したら、在庫確認の切り出しに戻ります。」
```

</details>

---

## Step 4 — 失敗からの学び（シナリオ）

> **このセクションは「失敗した場合」のシナリオ**です。
> 実際のリファクタリングで損切りを経験した場合の対処を学びます。

### シナリオ: 決済処理の切り出しで失敗

決済処理の切り出し中に、以下の問題が発生したとします。

```
問題:
- PaymentGatewayの戻り値の型が不明確
- エラーケースの網羅が困難
- 30分経過してもtypecheckが通らない
```

### 損切りの判断

```
┌─────────────────────────────────────────────────────────────────┐
│                    損切り判断チェックリスト                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✅ 損切り条件を満たしている:                                   │
│     [x] 3往復以上修正している                                   │
│     [x] 30分以上経過している                                    │
│     [x] 問題の根本原因が別の箇所にある                          │
│                                                                 │
│  決定: 損切りを実行する                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 損切り後のアクション

```
「決済処理の切り出しは一旦中止します。

問題: PaymentGatewayの型定義が不明確で、安全な切り出しができません。

次のアクションとして、以下を実行してください:

1. 現在の変更をすべて破棄（git checkout .）
2. Step 2の状態（バリデーション切り出し済み）に戻る
3. 以下を新しいタスクとして記録:
   - [ ] PaymentGatewayの型定義を明確化
   - [ ] 決済処理の切り出し（型定義後に実施）

この判断をCLAUDE.mdに記録してください。」
```

### CLAUDE.mdへの記録

```markdown
## 学び（追記）

### 2024-XX-XX: OrderServiceリファクタリング

**損切り判断:**
- 決済処理の切り出しで損切り実行
- 原因: PaymentGatewayの型定義が不明確

**教訓:**
- 外部サービスとの連携部分は、型定義を先に整理する
- 「動いているコード」でも、型が不明確だと安全な変更ができない

**次のアクション:**
- [ ] PaymentGatewayの型定義タスクを作成
- [ ] 型定義完了後に決済処理の切り出しを再開
```

---

## Step 5 — 完了と振り返り

### 完了した項目の確認

```
リファクタリング結果:

✅ 完了:
- 入力バリデーションの切り出し + 型定義
- 在庫確認ロジックの切り出し + テスト
- 通知処理の切り出し + エラーハンドリング改善

⏸️ 保留（別タスク化）:
- 決済処理の切り出し（PaymentGateway型定義待ち）

成果:
- processOrder関数: 500行 → 150行
- any型: 12箇所 → 2箇所（決済部分のみ）
- テストカバレッジ: 0% → 65%
```

### 振り返りの記録

```
「今回のリファクタリングの振り返りを行います。

以下の観点でまとめてください:
1. うまくいったこと
2. うまくいかなかったこと
3. 次回への教訓
4. CLAUDE.mdに追記すべき内容」
```

---

## ウォークスルーのまとめ

### リファクタリングの進め方

```
┌─────────────────────────────────────────────────────────────────┐
│              リファクタリングの進め方フロー                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 分析（コードを変更しない）                                  │
│     │                                                           │
│     ↓                                                           │
│  2. 計画（優先度とリスクを整理）                                │
│     │                                                           │
│     ↓                                                           │
│  3. 実行（1責務ずつ切り出し）                                   │
│     │                                                           │
│     ├─→ 成功 → コミット → 次の責務へ                          │
│     │                                                           │
│     └─→ 失敗 → 損切り判断                                      │
│              │                                                  │
│              ├─→ 損切り → 記録 → 別タスク化                   │
│              │                                                  │
│              └─→ 継続 → 問題の切り分け → 再試行              │
│                                                                 │
│  4. 振り返り（学びをCLAUDE.mdに記録）                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 損切りは「失敗」ではない

```
┌─────────────────────────────────────────────────────────────────┐
│                  損切りに対する正しい認識                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ❌ 間違った認識                                                │
│  「損切り = 失敗 = 恥ずかしいこと」                             │
│                                                                 │
│  ✅ 正しい認識                                                  │
│  「損切り = 賢明な判断 = 学びの機会」                           │
│                                                                 │
│  損切りによって得られるもの:                                    │
│  ・問題の根本原因の発見                                         │
│  ・より適切なタスク分解                                         │
│  ・将来の同様の問題への対処力                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 付録A-1, A-2との比較

| 観点 | A-1（ログイン） | A-2（CSV変換） | A-3（リファクタリング） |
|------|---------------|---------------|----------------------|
| 難易度 | ⭐ 初級 | ⭐⭐ 中級 | ⭐⭐⭐ 上級 |
| タスクタイプ | Type 1中心 | Type 1 + Type 2 | Type 2中心 |
| 損切り経験 | なし | 設定のみ | 実際に経験 |
| 失敗の扱い | エラー対処 | エラー対処 | 失敗の記録と学び |
| 主な学び | 基本フロー | パイプライン | 段階的改善 |

---

次のドキュメント: [付録B: トラブルシューティング](./appendix-b-troubleshooting.md)
